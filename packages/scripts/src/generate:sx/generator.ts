import fs from 'fs';
import path from 'path';

import PathResolver from './path-resolver';
import { CSSType, Style, StyleX } from './types';

const GENERATED_FILE_HEADER = `// This file is generated by styleX. Do not edit this file directly.\n\n`;

class Generator {
	private readonly resolver: PathResolver;

	constructor(root: string) {
		this.resolver = new PathResolver(root);
	}

	public generate(sx: StyleX) {
		this.generateStyles(sx.styles);

		this.generateGlobals();
	}

	private static generateValue(value: string, type: CSSType): string {
		switch (type) {
			case 'string':
				return `"${value}"`;
			case 'raw':
				return value;
			case 'pixel':
				return `#{pxrem(${value})}`;
			default:
				throw new Error(`unknown type ${type}`);
		}
	}

	private static generateMap(styles: Style[]): string {
		let content = '';

		styles.forEach((style) => {
			content += `$${style.name}: (\n`;

			const { length } = Object.keys(style.value);

			Object.entries(style.value).forEach(([key, value], index) => {
				content += `\t'${key}': `;

				if (value.length === 1) {
					content += Generator.generateValue(value[0], style.type[0]);
				}

				if (value.length > 1) {
					content += `(`;

					value.forEach((v, i) => {
						content += `${Generator.generateValue(v, style.type[i])}`;

						if (i < value.length - 1) {
							content += ', ';
						}
					});

					content += `)`;
				}

				if (index < length - 1) {
					content += ',\n';
				}
			});

			content += `\n);\n\n`;
		});

		return content;
	}

	private static generateVariables(styles: Style[]): string {
		let content = ':root {\n';

		styles.forEach((style) => {
			content += `\t@each $key, $value in $${style.name} {\n`;

			if (style.type.length === 1) {
				content += `\t\t--#{$prefix}-${style.variable.base}-#{$key}: $value;\n`;
			}

			if (
				style.type.length > 1 &&
				(!style.variable.sub || style.variable.sub.length === 1)
			) {
				content += `\t\t--#{$prefix}-${style.variable.base}-#{$key}: `;

				style.type.forEach((_, index) => {
					content += `nth($value, ${index + 1})`;

					if (index < style.type.length - 1) {
						content += ', ';
					}
				});

				content += `;\n`;
			}

			if (
				style.type.length > 1 &&
				!!style.variable.sub &&
				style.variable.sub?.length > 1
			) {
				style.type.forEach((_, index) => {
					content += `\t\t--#{$prefix}-${style.variable.base}-${style.variable
						.sub?.[index]}-#{$key}: nth($value, ${index + 1});\n`;
				});
			}

			content += `\t}\n`;
		});

		content += `}\n`;

		return content;
	}

	private static generateStyle(style: Style[]): string {
		let content = GENERATED_FILE_HEADER;

		content += Generator.generateMap(style);
		content += Generator.generateVariables(style);

		return content;
	}

	private generateStyles(styles: Record<string, Style[]>): void {
		const stylePath = this.resolver.getGeneratedStyleFolder();
		fs.rmdirSync(stylePath, { recursive: true });

		fs.mkdirSync(stylePath);

		Object.entries(styles).forEach(([key, value]) => {
			const filePath = path.join(stylePath, `_${key}.scss`);
			const file = fs.openSync(filePath, 'w');

			fs.writeSync(file, Generator.generateStyle(value));
		});
	}

	private generateGlobals(): void {
		const folders = this.resolver.getGeneratedFolders();
		const globals = fs.openSync(this.resolver.getGeneratedGlobalsFile(), 'w');

		let content = GENERATED_FILE_HEADER;

		folders.forEach((folder, i) => {
			const name = path.basename(folder);
			content += `@import\n`;

			const files = fs.readdirSync(folder);

			files.forEach((file, j) => {
				let fileName = path.basename(file, '.scss');

				if (fileName.startsWith('_')) {
					fileName = fileName.substring(1);
				}

				content += `\t'${name}/${fileName}'`;

				if (j < files.length - 1) {
					content += ',\n';
				}
			});

			if (i < folders.length - 1) {
				content += ';\n\n';
			} else {
				content += ';\n';
			}
		});

		fs.writeSync(globals, content);
	}
}

export default Generator;
